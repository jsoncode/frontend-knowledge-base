# 细化章节：Web API 扩展（Web APIs）

---

## 一、概述

现代浏览器提供了丰富的 **Web API**，使前端能够实现复杂功能，超越传统的 DOM 操作。这些 API 构成了“现代前端开发”的能力边界，是资深开发者必须掌握的核心技能。

> ✅ **Web API 分类**：
> - 存储类：`localStorage`, `sessionStorage`, `IndexedDB`, `Cache API`
> - 多线程类：`Web Workers`, `Service Workers`
> - 设备类：`Geolocation`, `Device Orientation`, `Battery`, `Vibration`
> - 通信类：`Fetch`, `WebSocket`, `WebRTC`, `BroadcastChannel`, `postMessage`
> - 文件与拖拽：`File API`, `Drag & Drop`, `Clipboard API`
> - 媒体类：`MediaDevices`, `Canvas`, `Web Audio API`
> - 性能与监控：`Performance API`, `Intersection Observer`, `MutationObserver`
> - 其他：`Fullscreen API`, `Page Visibility API`, `Notification API`

---

## 二、Web Storage（本地存储）

### 1. `localStorage` 与 `sessionStorage`

| 特性 | `localStorage` | `sessionStorage` |
|------|----------------|------------------|
| 持久性 | 永久（除非手动清除） | 会话级（关闭标签页即清除） |
| 作用域 | 同源共享 | 同源 + 同标签页 |
| 容量 | 约 5-10MB | 约 5-10MB |
| 数据类型 | 仅字符串（需 `JSON.stringify`） | 同左 |
| 事件 | `storage` 事件跨标签页通信 | 不触发 `storage` |

### 2. 常用操作

```js
// 存储
localStorage.setItem('theme', 'dark');
sessionStorage.setItem('token', 'abc123');

// 读取
const theme = localStorage.getItem('theme');

// 删除
localStorage.removeItem('theme');
localStorage.clear(); // 清空所有

// 监听变化（仅 localStorage）
window.addEventListener('storage', (e) => {
  console.log(`Key: ${e.key}, Old: ${e.oldValue}, New: ${e.newValue}`);
});
```

### 3. 使用场景与限制

- ✅ **适用场景**：
    - 用户偏好（主题、语言）
    - 缓存非敏感数据
    - 单页应用状态持久化
    - 跨标签页通信（`localStorage` + `storage` 事件）

- ❌ **限制**：
    - 同步阻塞（大量读写影响性能）
    - 仅字符串存储
    - 主线程操作，可能阻塞渲染
    - 容量有限，不适合大文件

> 💡 **技巧**：封装工具函数处理 JSON 序列化：
> ```js
> const Storage = {
>   set(key, value) {
>     localStorage.setItem(key, JSON.stringify(value));
>   },
>   get(key) {
>     const val = localStorage.getItem(key);
>     return val ? JSON.parse(val) : null;
>   }
> };
> ```

---

## 三、Web Workers（多线程）

### 1. 核心概念

- 允许在后台线程中运行 JavaScript，避免阻塞主线程（UI 线程）。
- 不能访问 DOM、`window`、`document` 等主线程对象。
- 通过 `postMessage` 与主线程通信。

### 2. 基本使用

#### 主线程（main.js）
```js
const worker = new Worker('worker.js');

worker.postMessage({ data: [1, 2, 3, 4, 5] });

worker.onmessage = function (e) {
  console.log('接收到结果:', e.data);
};

worker.onerror = function (e) {
  console.error('Worker 错误:', e.message);
};
```

#### Worker 线程（worker.js）
```js
self.onmessage = function (e) {
  const data = e.data.data;
  // 执行复杂计算
  const result = data.map(x => x * x);
  self.postMessage(result);
};
```

### 3. 使用场景

- 大数据处理（排序、过滤、解析）
- 图像/音视频编码解码
- 加密解密运算
- 长时间运行的任务（避免页面卡顿）

### 4. 注意事项

- Worker 文件必须通过 HTTP(S) 加载（不能 `file://`）
- 可以 `importScripts()` 引入其他脚本
- 可以递归创建子 Worker（`Nested Workers`）
- 内存独立，数据通过结构化克隆（Structured Clone）传递

> ⚠️ **不能传递**：函数、Error、DOM 节点、不可克隆对象

---

## 四、Service Workers（服务工作者）

### 1. 核心功能

- 一种特殊的 Web Worker，作为**网络代理**，拦截和控制页面的网络请求。
- 支持离线访问、资源缓存、消息推送、后台同步。
- 是 PWA（Progressive Web App）的核心技术。

### 2. 生命周期

1. **注册**：`navigator.serviceWorker.register('sw.js')`
2. **安装（install）**：缓存静态资源
3. **激活（activate）**：清除旧缓存，接管页面
4. **运行**：监听 `fetch`、`push`、`sync` 等事件

### 3. 基础示例（离线缓存）

#### 注册 SW
```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(reg => console.log('SW registered'))
    .catch(err => console.log('SW registration failed', err));
}
```

#### `sw.js`
```js
const CACHE_NAME = 'v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/styles.css',
  '/app.js'
];

// 安装时缓存资源
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// 拦截请求，优先返回缓存
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        return response || fetch(event.request);
      })
  );
});

// 激活时清理旧缓存
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(name => {
          if (name !== CACHE_NAME) {
            return caches.delete(name);
          }
        })
      );
    })
  );
});
```

### 4. 高级功能

- **Push Notifications**：通过 `push` 事件接收服务器推送
- **Background Sync**：网络恢复后自动同步数据
- **Cache API**：精细化控制缓存策略（Cache First, Network First, Stale While Revalidate）

---

## 五、Geolocation API（地理位置）

### 1. 获取用户位置

```js
if ('geolocation' in navigator) {
  navigator.geolocation.getCurrentPosition(
    (position) => {
      const { latitude, longitude } = position.coords;
      console.log(`位置: ${latitude}, ${longitude}`);
    },
    (error) => {
      console.error('获取位置失败:', error.message);
    },
    {
      enableHighAccuracy: true,  // 高精度（可能启用 GPS）
      timeout: 10000,            // 超时时间
      maximumAge: 60000          // 缓存时间（毫秒）
    }
  );
} else {
  console.log('浏览器不支持地理位置');
}
```

### 2. 持续监听位置变化

```js
const watchId = navigator.geolocation.watchPosition(
  (position) => {
    console.log('位置更新:', position.coords);
  },
  (error) => { /* 错误处理 */ }
);

// 停止监听
// navigator.geolocation.clearWatch(watchId);
```

### 3. 安全与隐私

- 必须用户授权（HTTPS 环境下才可请求）
- 位置精度受设备和环境影响
- 不可用于精确导航（如 GPS 级别）

---

## 六、Drag & Drop API

### 1. 基本流程

- 拖拽源：设置 `draggable="true"`
- 监听事件：`dragstart`, `drag`, `dragend`
- 目标区域：监听 `dragenter`, `dragover`, `drop`

### 2. 示例代码

```html
<div id="draggable" draggable="true">拖我</div>
<div id="dropzone">放这里</div>
```

```js
const draggable = document.getElementById('draggable');
const dropzone = document.getElementById('dropzone');

draggable.addEventListener('dragstart', (e) => {
  e.dataTransfer.setData('text/plain', 'Hello from drag');
  e.dataTransfer.effectAllowed = 'copy';
});

dropzone.addEventListener('dragover', (e) => {
  e.preventDefault(); // 允许放置
  e.dataTransfer.dropEffect = 'copy';
});

dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  const data = e.dataTransfer.getData('text/plain');
  dropzone.textContent = data;
});
```

### 3. 技巧

- `e.preventDefault()` 在 `dragover` 中必须调用，否则无法触发 `drop`
- `dataTransfer` 可存储多种格式数据
- 可拖拽文件（见 File API）

---

## 七、Clipboard API（剪贴板）

### 1. 读写剪贴板（需用户手势）

```js
// 写入文本
async function copyText(text) {
  try {
    await navigator.clipboard.writeText(text);
    console.log('复制成功');
  } catch (err) {
    console.error('复制失败:', err);
  }
}

// 读取文本
async function pasteText() {
  try {
    const text = await navigator.clipboard.readText();
    console.log('粘贴内容:', text);
  } catch (err) {
    console.error('读取失败:', err);
  }
}
```

### 2. 安全要求

- 必须在用户手势（click、keypress）中调用
- 需要 `https` 或 `localhost`
- 用户可能拒绝权限

> 💡 **兼容性降级**：
> 使用 `document.execCommand('copy')`（已废弃，仅作兜底）

---

## 八、其他重要 Web API

### 1. **Fullscreen API**
```js
element.requestFullscreen();     // 进入全屏
document.exitFullscreen();       // 退出全屏
document.fullscreenElement;      // 当前全屏元素
```

### 2. **Page Visibility API**
```js
document.hidden        // 页面是否隐藏
document.visibilityState  // 'visible', 'hidden', 'prerender'
document.addEventListener('visibilitychange', handler);
```

### 3. **Intersection Observer**
```js
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // 元素进入视口（可用于懒加载）
    }
  });
});
observer.observe(targetElement);
```

### 4. **MutationObserver**
```js
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    console.log('DOM 变化:', mutation);
  });
});
observer.observe(targetNode, { childList: true, subtree: true });
```

### 5. **Notification API**
```js
if (Notification.permission === 'granted') {
  new Notification('标题', { body: '内容' });
} else if (Notification.permission !== 'denied') {
  Notification.requestPermission().then(perm => {
    if (perm === 'granted') new Notification('Hello');
  });
}
```

---

## 九、面试高频问题

1. **`localStorage` 和 `Cookie` 有什么区别？**
   > - `localStorage` 容量大（5-10MB），不随请求发送，仅字符串。
   > - `Cookie` 容量小（4KB），随每次请求发送，支持过期、路径、域、安全属性。

2. **Web Worker 能访问 DOM 吗？如何通信？**
   > 不能。通过 `postMessage` 发送消息，监听 `onmessage` 接收。

3. **Service Worker 的作用是什么？如何实现离线访问？**
   > 作为网络代理，拦截请求并返回缓存资源。通过 `Cache API` 缓存关键资源，在 `fetch` 事件中优先返回缓存。

4. **如何实现图片懒加载？**
   > 使用 `Intersection Observer` 监听图片是否进入视口，进入后再加载 `src`。

5. **`navigator.clipboard` 为什么有时无法使用？**
   > 需用户手势触发、HTTPS 环境、用户授权。可降级使用 `execCommand`。

6. **Geolocation 获取的位置精确吗？**
   > 取决于设备（GPS、Wi-Fi、IP），精度从几米到几公里不等，不能用于高精度导航。

---

## 十、最佳实践与技巧

| 场景 | 推荐做法 |
|------|--------|
| 大数据计算 | 使用 Web Worker 避免阻塞 UI |
| 离线应用 | Service Worker + Cache API |
| 用户位置服务 | Geolocation + 错误处理 + 隐私提示 |
| 剪贴板操作 | `navigator.clipboard` + 权限检查 + 降级方案 |
| 懒加载 | `Intersection Observer` 替代滚动事件 |
| DOM 变化监听 | `MutationObserver` 替代轮询 |
| 跨标签页通信 | `BroadcastChannel` 或 `localStorage` + `storage` 事件 |
| 性能监控 | `Performance API` + `Navigation Timing` |

```js
// 使用 BroadcastChannel 实现标签页通信
const channel = new BroadcastChannel('chat');
channel.postMessage({ user: 'Alice', msg: 'Hi' });
channel.addEventListener('message', e => console.log(e.data));
```

---

> **总结**：  
> Web API 扩展了前端的能力边界。资深开发者应：
> - 熟练掌握常用 API 的使用场景与限制
> - 理解其背后的安全模型（如权限、同源）
> - 能结合多个 API 实现复杂功能（如 PWA）
> - 具备降级与兼容性处理能力
> - 关注性能与用户体验平衡
